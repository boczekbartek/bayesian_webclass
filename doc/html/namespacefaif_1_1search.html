<html><head><meta http-equiv="Content-Type" content="text/html;charset=utf-8">
<title>bayesian_webclass: faif::search Namespace Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacefaif.html">faif</a></li><li class="navelem"><a class="el" href="namespacefaif_1_1search.html">search</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">faif::search Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>the namespace of searching algorithms and optimization algorithms  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfaif_1_1search_1_1BooleanGene.html">BooleanGene</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfaif_1_1search_1_1compareWeight.html">compareWeight</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the comparizon used by searchUnifiedCost  <a href="structfaif_1_1search_1_1compareWeight.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfaif_1_1search_1_1compareWeightAndHeuristic.html">compareWeightAndHeuristic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the comparizon used by AStar  <a href="structfaif_1_1search_1_1compareWeightAndHeuristic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfaif_1_1search_1_1CrossoverCustom.html">CrossoverCustom</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">crossover policy - crossover from <a class="el" href="structfaif_1_1search_1_1Space.html" title="the typedef-s for space, where the fitness is defined as double ">Space</a>  <a href="structfaif_1_1search_1_1CrossoverCustom.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfaif_1_1search_1_1CrossoverNone.html">CrossoverNone</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">crossover policy - no crossover  <a href="structfaif_1_1search_1_1CrossoverNone.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfaif_1_1search_1_1EvolutionaryAlgorithm.html">EvolutionaryAlgorithm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the evolutionary algorithm  <a href="classfaif_1_1search_1_1EvolutionaryAlgorithm.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfaif_1_1search_1_1EvolutionaryAlgorithmGeneConcept.html">EvolutionaryAlgorithmGeneConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the concept for evolutionary algorithm gene the type gives the generateRandom method and the mutate method  <a href="structfaif_1_1search_1_1EvolutionaryAlgorithmGeneConcept.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfaif_1_1search_1_1EvolutionaryAlgorithmSpace.html">EvolutionaryAlgorithmSpace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the typedef-s for space for evolutionary algorithm, where the population is a vector of individuals, and the fitness is the double  <a href="structfaif_1_1search_1_1EvolutionaryAlgorithmSpace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfaif_1_1search_1_1EvolutionaryAlgorithmSpaceConcept.html">EvolutionaryAlgorithmSpaceConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the concept for evolutionary algorithm space  <a href="structfaif_1_1search_1_1EvolutionaryAlgorithmSpaceConcept.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfaif_1_1search_1_1EvolutionaryAlgorithmSpaceWithCrossoverConcept.html">EvolutionaryAlgorithmSpaceWithCrossoverConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the concept for evolutionary algorithm space  <a href="structfaif_1_1search_1_1EvolutionaryAlgorithmSpaceWithCrossoverConcept.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfaif_1_1search_1_1EvolutionaryAlgorithmSpaceWithMutationConcept.html">EvolutionaryAlgorithmSpaceWithMutationConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the concept for evolutionary algorithm space  <a href="structfaif_1_1search_1_1EvolutionaryAlgorithmSpaceWithMutationConcept.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfaif_1_1search_1_1ExpectationCustom.html">ExpectationCustom</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">expectation policy - custiom  <a href="structfaif_1_1search_1_1ExpectationCustom.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfaif_1_1search_1_1ExpectationMaximization.html">ExpectationMaximization</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the Expectation-Maximization algorithm  <a href="classfaif_1_1search_1_1ExpectationMaximization.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfaif_1_1search_1_1ExpectationNone.html">ExpectationNone</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">expectation policy (empty)  <a href="structfaif_1_1search_1_1ExpectationNone.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfaif_1_1search_1_1HillClimbing.html">HillClimbing</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the hill climbing algorithm. Search the neighbour for the better solution  <a href="classfaif_1_1search_1_1HillClimbing.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfaif_1_1search_1_1MaximizationCustom.html">MaximizationCustom</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximization policy - custiom  <a href="structfaif_1_1search_1_1MaximizationCustom.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfaif_1_1search_1_1MaximizationNone.html">MaximizationNone</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximization policy (empty) n  <a href="structfaif_1_1search_1_1MaximizationNone.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfaif_1_1search_1_1MutationCustom.html">MutationCustom</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">mutation policy - mutation from <a class="el" href="structfaif_1_1search_1_1Space.html" title="the typedef-s for space, where the fitness is defined as double ">Space</a>  <a href="structfaif_1_1search_1_1MutationCustom.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfaif_1_1search_1_1MutationNone.html">MutationNone</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">mutation policy - no mutation  <a href="structfaif_1_1search_1_1MutationNone.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfaif_1_1search_1_1NextNodeCheckAll.html">NextNodeCheckAll</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the policy class for <a class="el" href="classfaif_1_1search_1_1HillClimbing.html" title="the hill climbing algorithm. Search the neighbour for the better solution ">HillClimbing</a>, check all neighbours  <a href="structfaif_1_1search_1_1NextNodeCheckAll.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfaif_1_1search_1_1Node.html">Node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the struct to create node in search space from individual  <a href="structfaif_1_1search_1_1Node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfaif_1_1search_1_1NodeWithChildrenConcept.html">NodeWithChildrenConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the concept for node with children  <a href="structfaif_1_1search_1_1NodeWithChildrenConcept.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfaif_1_1search_1_1NodeWithFinalFlagConcept.html">NodeWithFinalFlagConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the concept for node with final flag for search in tree-like structures The function 'searchDepthFirst' and 'searchBreadthFirst' require this concept  <a href="structfaif_1_1search_1_1NodeWithFinalFlagConcept.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfaif_1_1search_1_1SelectionRanking.html">SelectionRanking</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">succession and selection policy - the n-th best individuals survive  <a href="structfaif_1_1search_1_1SelectionRanking.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfaif_1_1search_1_1SelectionRoulette.html">SelectionRoulette</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">succession and selection policy - roulette wheel (probability of selection of an idividual is equal to its normalized fitness)  <a href="structfaif_1_1search_1_1SelectionRoulette.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfaif_1_1search_1_1Space.html">Space</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the typedef-s for space, where the fitness is defined as double  <a href="structfaif_1_1search_1_1Space.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfaif_1_1search_1_1SpaceConcept.html">SpaceConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the concept for space with fitness  <a href="structfaif_1_1search_1_1SpaceConcept.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfaif_1_1search_1_1StopAfterNSteps.html">StopAfterNSteps</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop condition, finish the algorithm after STEPS_NUM iterations.  <a href="structfaif_1_1search_1_1StopAfterNSteps.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfaif_1_1search_1_1TransformationCustomTag.html">TransformationCustomTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">trait tag, user tranformation should be executed  <a href="structfaif_1_1search_1_1TransformationCustomTag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfaif_1_1search_1_1TransformationNoneTag.html">TransformationNoneTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">trait tag, no transformation should be executed  <a href="structfaif_1_1search_1_1TransformationNoneTag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfaif_1_1search_1_1TreeNode.html">TreeNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the template to create the node in tree-based search methods  <a href="classfaif_1_1search_1_1TreeNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfaif_1_1search_1_1TreeNodeHeuristicConcept.html">TreeNodeHeuristicConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the concept for heuristic search algorithms, it check the presence of 'getHeuristic' method, used by heuristic search functions e.g. 'searchAStar'  <a href="structfaif_1_1search_1_1TreeNodeHeuristicConcept.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfaif_1_1search_1_1TreeNodeWeightConcept.html">TreeNodeWeightConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the concept for informed search algorithms, it check the presence of 'getWeight' method, used by informed search functions e.g. 'searchUniformCost'  <a href="structfaif_1_1search_1_1TreeNodeWeightConcept.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfaif_1_1search_1_1VectorIndividual.html">VectorIndividual</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template to generate individual which is the vector of Genes.  <a href="classfaif_1_1search_1_1VectorIndividual.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfaif_1_1search_1_1VoseAlg.html">VoseAlg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">helping class implemented the M.D.Vose (1991) algorithm  <a href="classfaif_1_1search_1_1VoseAlg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af56d7e2e36411397cc8b28291d456940"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af56d7e2e36411397cc8b28291d456940"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefaif_1_1search.html#af56d7e2e36411397cc8b28291d456940">checkNodeInPath</a> (const <a class="el" href="classfaif_1_1search_1_1TreeNode.html">TreeNode</a>&lt; T &gt; &amp;n)</td></tr>
<tr class="separator:af56d7e2e36411397cc8b28291d456940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d22d52308164d93a6577b8cdb254ac1"><td class="memTemplParams" colspan="2">template&lt;typename Node &gt; </td></tr>
<tr class="memitem:a7d22d52308164d93a6577b8cdb254ac1"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefaif_1_1search.html#a7d22d52308164d93a6577b8cdb254ac1">operator&lt;&lt;</a> (std::ostream &amp;os, const std::vector&lt; boost::shared_ptr&lt; <a class="el" href="structfaif_1_1search_1_1Node.html">Node</a> &gt; &gt; &amp;path)</td></tr>
<tr class="memdesc:a7d22d52308164d93a6577b8cdb254ac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">helping function for debugging  <a href="#a7d22d52308164d93a6577b8cdb254ac1">More...</a><br /></td></tr>
<tr class="separator:a7d22d52308164d93a6577b8cdb254ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5958afbc54cebcf279140e9352e9e93c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5958afbc54cebcf279140e9352e9e93c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structfaif_1_1search_1_1Node.html">Node</a>&lt; T &gt;::Path&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefaif_1_1search.html#a5958afbc54cebcf279140e9352e9e93c">searchAStar</a> (boost::shared_ptr&lt; T &gt; start, int max=200)</td></tr>
<tr class="memdesc:a5958afbc54cebcf279140e9352e9e93c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A* (A star) search algorithm.  <a href="#a5958afbc54cebcf279140e9352e9e93c">More...</a><br /></td></tr>
<tr class="separator:a5958afbc54cebcf279140e9352e9e93c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf283e3eec698e0cb0ca5200f2c001eb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adf283e3eec698e0cb0ca5200f2c001eb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structfaif_1_1search_1_1Node.html">Node</a>&lt; T &gt;::Path&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefaif_1_1search.html#adf283e3eec698e0cb0ca5200f2c001eb">searchBreadthFirst</a> (boost::shared_ptr&lt; T &gt; start, int max=200)</td></tr>
<tr class="memdesc:adf283e3eec698e0cb0ca5200f2c001eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The breadth-first search algorithm.  <a href="#adf283e3eec698e0cb0ca5200f2c001eb">More...</a><br /></td></tr>
<tr class="separator:adf283e3eec698e0cb0ca5200f2c001eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9ce823131aa3f7b37089f2eb1b0fd8f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac9ce823131aa3f7b37089f2eb1b0fd8f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structfaif_1_1search_1_1Node.html">Node</a>&lt; T &gt;::Path&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefaif_1_1search.html#ac9ce823131aa3f7b37089f2eb1b0fd8f">searchDepthFirst</a> (boost::shared_ptr&lt; T &gt; start, int max=200)</td></tr>
<tr class="memdesc:ac9ce823131aa3f7b37089f2eb1b0fd8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The depth-first search algorithm (DFS)  <a href="#ac9ce823131aa3f7b37089f2eb1b0fd8f">More...</a><br /></td></tr>
<tr class="separator:ac9ce823131aa3f7b37089f2eb1b0fd8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e29a906a7e17a5d892a63dee4a2cced"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6e29a906a7e17a5d892a63dee4a2cced"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structfaif_1_1search_1_1Node.html">Node</a>&lt; T &gt;::Path&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefaif_1_1search.html#a6e29a906a7e17a5d892a63dee4a2cced">searchUnifiedCost</a> (boost::shared_ptr&lt; T &gt; start, int max=200)</td></tr>
<tr class="memdesc:a6e29a906a7e17a5d892a63dee4a2cced"><td class="mdescLeft">&#160;</td><td class="mdescRight">uniform-cost search algorithm (informed search)  <a href="#a6e29a906a7e17a5d892a63dee4a2cced">More...</a><br /></td></tr>
<tr class="separator:a6e29a906a7e17a5d892a63dee4a2cced"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>the namespace of searching algorithms and optimization algorithms </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="af56d7e2e36411397cc8b28291d456940"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool faif::search::checkNodeInPath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfaif_1_1search_1_1TreeNode.html">TreeNode</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>check if the node is twice on the path </p>

<p>Definition at line <a class="el" href="TreeNodeImpl_8hpp_source.html#l00082">82</a> of file <a class="el" href="TreeNodeImpl_8hpp_source.html">TreeNodeImpl.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7d22d52308164d93a6577b8cdb254ac1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Node &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; faif::search::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; boost::shared_ptr&lt; <a class="el" href="structfaif_1_1search_1_1Node.html">Node</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>helping function for debugging </p>

<p>Definition at line <a class="el" href="Node_8hpp_source.html#l00034">34</a> of file <a class="el" href="Node_8hpp_source.html">Node.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5958afbc54cebcf279140e9352e9e93c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfaif_1_1search_1_1Node.html">Node</a>&lt;T&gt;::Path faif::search::searchAStar </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; T &gt;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max</em> = <code>200</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A* (A star) search algorithm. </p>
<p>heuristic searching tree-like structures, finds the least-cost path from initial node to goal node, uses a distance function which is a sum of path-cost and a heuristic estimate of the distance to the goal</p>
<p>Function is protected against the cycles in the graph. The maximum depth of tree is limited. </p>

<p>Definition at line <a class="el" href="AStar_8h_source.html#l00035">35</a> of file <a class="el" href="AStar_8h_source.html">AStar.h</a>.</p>

</div>
</div>
<a class="anchor" id="adf283e3eec698e0cb0ca5200f2c001eb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfaif_1_1search_1_1Node.html">Node</a>&lt;T&gt;::Path faif::search::searchBreadthFirst </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; T &gt;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max</em> = <code>200</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The breadth-first search algorithm. </p>
<p>from starting state the function build the tree structure, explores all the nearest nodes (children), and if it not find the goal generates the nearest nodes to the children. The return is the shortest path from root node to the goal node. Function is protected against the cycles in the graph. The maximum depth of tree is limited. </p>

<p>Definition at line <a class="el" href="BreadthFirst_8h_source.html#l00030">30</a> of file <a class="el" href="BreadthFirst_8h_source.html">BreadthFirst.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac9ce823131aa3f7b37089f2eb1b0fd8f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfaif_1_1search_1_1Node.html">Node</a>&lt;T&gt;::Path faif::search::searchDepthFirst </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; T &gt;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max</em> = <code>200</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The depth-first search algorithm (DFS) </p>
<p>from starting state the function build the tree structure, explores as far as possible, backtracks. Function uses the protection against the cycles in the graph and the maximum depth of tree border.</p>
<dl class="section return"><dt>Returns</dt><dd>the first path from the starting to the finishing state. </dd></dl>

<p>Definition at line <a class="el" href="DepthFirst_8h_source.html#l00026">26</a> of file <a class="el" href="DepthFirst_8h_source.html">DepthFirst.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6e29a906a7e17a5d892a63dee4a2cced"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfaif_1_1search_1_1Node.html">Node</a>&lt;T&gt;::Path faif::search::searchUnifiedCost </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; T &gt;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max</em> = <code>200</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>uniform-cost search algorithm (informed search) </p>
<p>the uniform-cost search algorithm, traversing a tree structure, visit the next node which has the least total cost from the root. Algorithm use the 'getWeight' function of node.</p>
<p>Function is protected against the cycles in the graph. The maximum depth of tree is limited. </p>

<p>Definition at line <a class="el" href="UnifiedCost_8h_source.html#l00036">36</a> of file <a class="el" href="UnifiedCost_8h_source.html">UnifiedCost.h</a>.</p>

</div>
</div>
</div><!-- contents -->

<br clear="all" />
<hr size="1"><div style="align: right;">
<a href="http://wiki.ros.org/bayesian_webclass">bayesian_webclass</a><br />
Author(s): </br />
<small>autogenerated on Sun Jan 22 2017 17:49:28</small>
</div>
</body>
</html>
